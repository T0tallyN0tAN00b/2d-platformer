<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Fast Smiley Jumper</title>
<style>
body { margin:0; overflow:hidden; background:#87CEEB; }
canvas { display:block; cursor:pointer; background:#87CEEB; }
</style>
</head>
<body>
<canvas id="gameCanvas"></canvas>
<script>
const canvas=document.getElementById('gameCanvas');
const ctx=canvas.getContext('2d');
canvas.width=800;
canvas.height=400;

// Game constants
const gravity=0.6;
const autoScrollSpeed=1.2;
const maxParticles=80;

// Game state
let platforms=[];
const platformCount=12;
let scrollY=0;
let score=0;
let gameOver=false;

// Player
const player={x:100,y:0,width:40,height:40,dy:0,speed:5,jumpsLeft:2,canJump:true};

// Particles
let particles=[];
function createParticles(x,y,color,count=6){
  for(let i=0;i<count;i++){
    if(particles.length>=maxParticles) break;
    particles.push({
      x:x+player.width/2, y:y+player.height/2,
      dx:(Math.random()-0.5)*2.5,
      dy:(Math.random()-0.5)*2.5,
      size:Math.random()*3+1,
      life:20,
      color
    });
  }
}
function updateParticles(){
  // Update particles
  particles.forEach(p=>{
    p.x+=p.dx; p.y+=p.dy;
    p.size*=0.95;
    p.life--;
  });
  // Keep only alive particles
  particles=particles.filter(p=>p.life>0);
  // Draw
  particles.forEach(p=>{
    ctx.fillStyle=p.color;
    ctx.fillRect(p.x,p.y,p.size,p.size);
  });
}

// Platforms
function createPlatforms(offsetY=0){
  let lastY=offsetY+canvas.height-50;
  for(let i=0;i<platformCount;i++){
    let width=Math.random()*100+60;
    let x=Math.random()*(canvas.width-width);
    let y=lastY-(Math.random()*30+50);
    platforms.push({x,y,width,height:10});
    lastY=y;
  }
}

// Draw
function drawPlayer(){
  ctx.fillStyle='orange';
  ctx.fillRect(player.x,player.y,player.width,player.height);
  ctx.strokeStyle='black';
  ctx.strokeRect(player.x,player.y,player.width,player.height);
  // Smiley
  ctx.fillStyle='black';
  ctx.beginPath();
  ctx.arc(player.x+12,player.y+15,3,0,Math.PI*2);
  ctx.arc(player.x+28,player.y+15,3,0,Math.PI*2);
  ctx.fill();
  ctx.beginPath();
  ctx.arc(player.x+20,player.y+25,8,0,Math.PI);
  ctx.stroke();
}
function drawPlatforms(){
  ctx.fillStyle='green';
  platforms.forEach(p=>ctx.fillRect(p.x,p.y,p.width,p.height));
}
function drawScore(){
  ctx.fillStyle='black';
  ctx.font='20px Arial';
  ctx.fillText('Score: '+Math.floor(score),10,30);
}
function drawGameOver(){
  ctx.fillStyle="rgba(0,0,0,0.5)";
  ctx.fillRect(0,0,canvas.width,canvas.height);
  ctx.fillStyle="white";
  ctx.font="40px Arial";
  ctx.fillText("Game Over!",canvas.width/2-100,canvas.height/2-40);
  ctx.font="25px Arial";
  ctx.fillText("Score: "+Math.floor(score),canvas.width/2-60,canvas.height/2);
  ctx.fillStyle="red";
  ctx.fillRect(canvas.width/2-75,canvas.height/2+40,150,50);
  ctx.fillStyle="white";
  ctx.font="22px Arial";
  ctx.fillText("Restart",canvas.width/2-40,canvas.height/2+72);
}

// Input
const keys={};
document.addEventListener('keydown',e=>keys[e.code]=true);
document.addEventListener('keyup',e=>{keys[e.code]=false; player.canJump=true;});
canvas.addEventListener('click',e=>{
  if(gameOver){
    const mx=e.offsetX,my=e.offsetY;
    if(mx>canvas.width/2-75 && mx<canvas.width/2+75 && my>canvas.height/2+40 && my<canvas.height/2+90)
      restartGame();
  }
});

// Restart
function restartGame(){
  platforms=[]; particles=[]; scrollY=0; score=0; gameOver=false;
  player.dy=0; player.jumpsLeft=2;
  createPlatforms();
  const lowest=platforms.reduce((a,b)=>a.y>b.y?a:b);
  player.x=lowest.x+lowest.width/2-player.width/2;
  player.y=lowest.y-player.height;
}

// Game loop
function gameLoop(){
  if(!gameOver){
    // Movement
    if(keys['ArrowLeft']) player.x-=player.speed;
    if(keys['ArrowRight']) player.x+=player.speed;
    if(keys['ArrowUp'] && player.canJump && player.jumpsLeft>0){
      player.dy=-15;
      if(player.jumpsLeft===2) createParticles(player.x,player.y,'orange',8);
      else createParticles(player.x,player.y,'white',12);
      player.jumpsLeft--;
      player.canJump=false;
    }

    // Gravity
    player.dy+=gravity;
    player.y+=player.dy;

    // Collision
    let landed=false;
    for(let p of platforms){
      if(player.x+player.width>p.x && player.x<p.x+p.width &&
         player.y+player.height>p.y && player.y+player.height<p.y+p.height+player.dy &&
         player.dy>=0){
           player.dy=0;
           player.y=p.y-player.height;
           landed=true;
           if(player.jumpsLeft<2) createParticles(player.x,player.y,'orange',5);
           player.jumpsLeft=2;
         }
    }

    // Auto-scroll
    player.y+=autoScrollSpeed;
    platforms.forEach(p=>p.y+=autoScrollSpeed);
    scrollY+=autoScrollSpeed;

    // Remove off-screen platforms
    platforms=platforms.filter(p=>p.y<canvas.height+50);

    // Generate new platforms
    if(Math.min(...platforms.map(p=>p.y))>0) createPlatforms(-canvas.height);

    if(player.y>canvas.height) gameOver=true;

    score=Math.max(score,scrollY);
  }

  // Draw
  ctx.clearRect(0,0,canvas.width,canvas.height);
  drawPlatforms();
  drawPlayer();
  updateParticles();
  drawScore();
  if(gameOver) drawGameOver();

  requestAnimationFrame(gameLoop);
}

// INIT
createPlatforms();
const lowest=platforms.reduce((a,b)=>a.y>b.y?a:b);
player.x=lowest.x+lowest.width/2-player.width/2;
player.y=lowest.y-player.height;

gameLoop();
</script>
</body>
</html>
